\chapter{Introdução}
\label{intro}

Algoritmos gulosos são uma popular escolha para resolução de problemas de otimização, com um dos primeiros registros de sua utilização datando de 1952, com a Codificação de Huffman~\cite{huffman1952method}.

Abordagens gulosas nem sempre produzem a solução ótima, mas quando produzem, são mais eficientes quando comparadas com, por exemplo, Programação Dinâmica ou força bruta.

Eles são muito difíceis de se definir precisamente. Há pesquisa para formalizar a classe de problemas considerados gulosos, como os trabalhos de Edmonds~\cite{Edmonds1971} e Lawler~\cite{lawler2001combinatorial} na teoria dos matroides, e o trabalho de Borodin, Nielsen e Rackoff~\cite{Borodin2003} na definição de \quotes{guloso}.

Em seu livro didático, Cormen~\cite{CLRS} define algoritmos gulosos como algoritmos que apresentam \emph{propriedade de escolha gulosa}: conseguimos chegar na solução ótima global através de escolhas localmente ótimas (escolhas gulosas). Isto é, em contraste com a programação dinâmica, que cada escolha depende dos subproblemas, num algoritmo guloso fazemos a escolha que parece melhor para a situação atual, sem considerar os subproblemas, e, mais importante, uma vez que uma decisão é tomada, não a mudamos mais.

\section{Objetivos}

Neste trabalho apresentamos algoritmos gulosos de uma maneira pragmática, a partir de problemas de competições de programação, como a Maratona de Programação\footnote{\url{http://maratona.ime.usp.br/}}, destoando dos problemas clássicos que são frequentemente abordados nos livros-texto.

Além de apresentar os conceitos paralelamente às soluções para os problemas, focamos também em desenvolver o raciocínio e a intuição por trás das técnicas gulosas, a fim de criar uma ferramenta sistemática para resolvê-los.

\section{Estrutura do texto}

No capítulo \ref{salto} apresentamos o argumento de troca, uma ferramento versátil para demonstração de corretude de algoritmos gulosos que será utilizada nos demais capítulos.

Nos capítulos \ref{ordenacao} e \ref{subproblema} investigamos como podemos reduzir problemas a ponto de aceitarem soluções gulosas. Discutimos também como a utilização de estruturas de dados auxiliares aliado ao algoritmo guloso pode diminuir sua complexidade computacional.

No capítulo \ref{pd} mostramos como algoritmos gulosos e programação dinâmica, duas técnicas distintas para resolução de problemas de otimização, podem ser utilizadas em conjunto.

No capítulo \ref{particao} exploramos como restrições na entrada de um problema podem mudar completamente a natureza de sua solução, podendo admitir soluções gulosas que não seriam possíveis sem as restrições.

Além do problema analisado, cada capítulo propõe exercícios teóricos de aprofundamento no conteúdo e exercícios práticos no estilo programação competitiva.

\section{Programação competitiva}

Programação competitiva é um esporte da mente onde os participantes devem resolver tarefas, normalmente relacionadas à lógica, algoritmos e estruturas de dados, dentro de um período de limitado tempo, seguindo restrições de processamento e espaço.

Uma das competições mais antigas é a \emph{International Collegiate Programming Contest (ICPC)}, que reúne estudantes de milhares de universidades de centenas de países ao redor do mundo, competindo em trios num mesmo computador durante cinco horas. Existem diversas competições que seguem o modelo da \emph{ICPC}, como \emph{Northwestern Europe Regional Contest (NWERC)}, \emph{Benelux Algorithm Programming Contest (BAPC)}. Problemas destas competições são disponibilizados em arquivos de problemas chamados \quotes{juízes}, como \emph{LiveArchive}, \emph{Kattis} e \emph{SPOJ}.

Outro modelo popular de competição são os \emph{contests online}, que normalmente são individuais e tem periodicamente semanal ou bissemanal, hospedadas e promovidas por sites como o \emph{CodeForces} e \emph{CodeChef}.

Os problemas práticos propostos neste trabalho estão disponíveis nesses \quotes{juízes}. Além de resolver teoricamente, é possível implementar numa linguagem de programação e submeter para uma correção automática, que compara a saída do programa submetido com as saídas esperadas.

Os vereditos mais comuns são \emph{Accepted} ou \emph{AC}, quando o programa está correto, \emph{Wrong Answer} ou \emph{WA}, quando o programa produz resposta errada para algum caso, e \emph{Time Limit Exceeded} ou \emph{TLE}, quando a solução entra em \emph{loop} infinito ou não possui complexidade computacional adequada para as restrições.